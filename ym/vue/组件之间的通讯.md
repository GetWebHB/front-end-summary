## 1. 组件之间的通信
##### 1. 父子组件传递（props/$emit)

```js
defineProps

// 父组件

<Children message="hello ice">

// 子组件

const props = defineProps({
  message: String
})
```

```js
defineEmits

// 子组件

<button @click='btnClick'>add</button>

const value = 'xbc'
const emit = defineEmits(['add'])
const btnClick = () => {
  emit('add', value)
}

// 父组件
<children @add='add'>

const add = (value) = > {
  console.log(value)
}
````

#####  2. 依赖注入（provide/inject)
root

```js
provide('message', 'hello xbc!')
```
deepChildren

```js
const message = inject('message')
```

##### 3.EventBus
```js
EventBus.$bus.emit('click')
EventBus.$bus.on('click', () => {
	console.log('hello')
})
```

##### 4.Vuex
```js
import { createStore } from 'vuex'
const store = createStore({
	state: () => {
		return {
			message: 'xbc'
		}
	},
	getters: {},
	mutation: {
		changeMessage(state, newMessage) {
			state.message = newMessage
		}
	},
	actions: {
		change({commit}, payload) {
			commit('changeMessage', payload)
		}
	},
	modules: {}
})
export default store


<button @click = 'change'>

import {useStore} from 'vuex'
const store = useStore()
const change = () => {
	store.dispatch('change', 'xbcny')
}
```

## 2.组件实例
	通过组件实例获取组件里面的方法或者属性

```js
const child = ref(null)

<ChildCpn ref="child" />

// child.method
```

## 3.watch与watchEffect的区别
	watch函数监听特定的数据，并在回调函数中执行副作用，默认情况下第一次是不会执行的，响应式状态发生变化时才会触发回调函数
	watchEffect，我们希望在创建侦听器时，立即执行一遍回调
	手动停止监听，调用 watch 或 watchEffect 返回的函数
```js
watch(source, callback, [options])
source: ref (包括计算属性)、响应式对象、getter 函数、或多个数据源组成的数组
callback: 回调函数
options: 
	deep(深度监听，遍历被监听对象中所有被嵌套的属性) 
	immediate(watch监听是惰性的，设置了之后第一次会立即执行) 
	flush(当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。
	默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。
	如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: 'post' )，或者使用watchPostEffect(() => {
  /* 在 Vue 更新后执行 */
	})

watchEffect:
```

## 4.reactive, ref, toRefs
	reactive: 处理对象的双向绑定，不能处理基本数据类型
	ref: 可以处理基础数据类型与对象类型的双向绑定，，接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 .value
	toRefs: 可以将一个reactive对象的属性处理成为ref类型的数据
## 5.水平垂直居中的方案
```
1 已知宽高
方法一
.parent {
	position: relative
}
.child {
	position: absolute
	width: 200px
	height: 200px
	top： 0
	bottom: 0
	left: 0
	right: 0
	margin: auto
}
方法二
.parent {
	position: relative
}
.child {
	position: absolute
	width: 200px
	height: 200px
	top: 50%
	left: 50%
	margin-top: -100px
	margin-left: -100px
}
2 未知宽高
方法一
.parent {
	position: relative
}
.child {
	position: absolute
	top: 50%
	left: 50%
	tranform: translate(-50%, -50%)
}
方法二
.parent {
	display: flex
	justify-contnt: center
	align-items: center
}
方法三
.parent {
	display: grid
}
.child {
	justify-self: center
	align-self: center
}
```
## 6.vue的修饰符
事件修饰符可以链式使用，使用修饰符时需要注意调用顺序
```
1.number: 将值转化为number类型，如果值是字母则无效，如果前面是数字类型后面是字母类型，那么只会选取前面的数字
2.once: 事件最多被触发一次
3.lazy: 输入框双向绑定数据，v-model绑定的值不会在用户改变输入框的值的时候立马发生变化，当鼠标离开之后才会更新
4.trim: 可以将值的首位空格去掉
5.stop: 可以阻止事件冒泡
6.prevent: 阻止默认事件的发生
7.capture: 事件冒泡默认是由内向外，capture是让指向内部元素的事件，在被内部元素处理前，先被外部处理
8.passive: 一般用于触摸事件的监听器
9.left/right/middle: 鼠标的左右中按键点击时候触发的事件
```
## 7.vue指令
```
1.v-text: 更新元素的textContent
2.v-html: 更新元素的innerHtml
3.v-show: 不论表达式是真是假都会渲染元素，通过切换元素的CSS display，当条件改变时，也会触发过渡效果
4.v-if: 表达式值的真假性，来条件性地渲染元素
5.v-else: 类似于js中的if else的使用，前一个元素必须要由v-if
6.v-else-if: 类似于js中的if if-else-if,前一个元素可以是v-if或者v-else-if
7.v-for: 列表循环的渲染，期望的值Array | Object | number | string | Iterable
8.v-on: 给元素绑定事件监听器,可以缩写成@
9.v-bind: 动态的绑定一个或多个 attribute（可以是对象形式），也可以是组件的 prop，缩写是：
10.v-model: 双向绑定表单选项的值
11.v-slot: 声明具名插槽名，默认是default,只有在给作用域插槽传递 props 才需要
12.v-once: 元素和组件只能渲染一次
```