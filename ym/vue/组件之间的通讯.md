## 1. 组件之间的通信
##### 1. 父子组件传递（props/$emit)

```js
defineProps

// 父组件

<Children message="hello ice">

// 子组件

const props = defineProps({
  message: String
})
```

```js
defineEmits

// 子组件

<button @click='btnClick'>add</button>

const value = 'xbc'
const emit = defineEmits(['add'])
const btnClick = () => {
  emit('add', value)
}

// 父组件
<children @add='add'>

const add = (value) = > {
  console.log(value)
}
````

#####  2. 依赖注入（provide/inject)
root

```js
provide('message', 'hello xbc!')
```
deepChildren

```js
const message = inject('message')
```

##### 3.EventBus
```js
EventBus.$bus.emit('click')
EventBus.$bus.on('click', () => {
	console.log('hello')
})
```

##### 4.Vuex
```js
import { createStore } from 'vuex'
const store = createStore({
	state: () => {
		return {
			message: 'xbc'
		}
	},
	getters: {},
	mutation: {
		changeMessage(state, newMessage) {
			state.message = newMessage
		}
	},
	actions: {
		change({commit}, payload) {
			commit('changeMessage', payload)
		}
	},
	modules: {}
})
export default store


<button @click = 'change'>

import {useStore} from 'vuex'
const store = useStore()
const change = () => {
	store.dispatch('change', 'xbcny')
}
```

## 2.组件实例
	通过组件实例获取组件里面的方法或者属性

```js
const child = ref(null)

<ChildCpn ref="child" />

// child.method
```

## 3.watch与watchEffect的区别
	watch函数监听特定的数据，并在回调函数中执行副作用，默认情况下第一次是不会执行的，响应式状态发生变化时才会触发回调函数
	watchEffect，我们希望在创建侦听器时，立即执行一遍回调
	手动停止监听，调用 watch 或 watchEffect 返回的函数
```js
watch(source, callback, [options])
source: ref (包括计算属性)、响应式对象、getter 函数、或多个数据源组成的数组
callback: 回调函数
options: 
	deep(深度监听，遍历被监听对象中所有被嵌套的属性) 
	immediate(watch监听是惰性的，设置了之后第一次会立即执行) 
	flush(当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。
	默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。
	如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: 'post' )，或者使用watchPostEffect(() => {
  /* 在 Vue 更新后执行 */
	})

watchEffect:
```

## 4.reactive, ref, toRefs
	reactive: 处理对象的双向绑定，不能处理基本数据类型
	ref: 可以处理基础数据类型与对象类型的双向绑定，，接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 .value
	toRefs: 可以将一个reactive对象的属性处理成为ref类型的数据
## 5.水平垂直居中的方案
```
1 已知宽高
方法一
.parent {
	position: relative
}
.child {
	position: absolute
	width: 200px
	height: 200px
	top： 0
	bottom: 0
	left: 0
	right: 0
	margin: auto
}
方法二
.parent {
	position: relative
}
.child {
	position: absolute
	width: 200px
	height: 200px
	top: 50%
	left: 50%
	margin-top: -100px
	margin-left: -100px
}
2 未知宽高
方法一
.parent {
	position: relative
}
.child {
	position: absolute
	top: 50%
	left: 50%
	tranform: translate(-50%, -50%)
}
方法二
.parent {
	display: flex
	justify-contnt: center
	align-items: center
}
方法三
.parent {
	display: grid
}
.child {
	justify-self: center
	align-self: center
}
```
	