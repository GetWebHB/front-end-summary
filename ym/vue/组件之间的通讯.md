## 1. 组件之间的通信
##### 1. 父子组件传递（props/$emit)

```js
defineProps

// 父组件

<Children message="hello ice">

// 子组件

const props = defineProps({
  message: String
})
```

```js
defineEmits

// 子组件

<button @click='btnClick'>add</button>

const value = 'xbc'
const emit = defineEmits(['add'])
const btnClick = () => {
  emit('add', value)
}

// 父组件
<children @add='add'>

const add = (value) = > {
  console.log(value)
}
````

#####  2. 依赖注入（provide/inject)
root

```js
provide('message', 'hello xbc!')
```
deepChildren

```js
const message = inject('message')
```

##### 3.EventBus
```js
EventBus.$bus.emit('click')
EventBus.$bus.on('click', () => {
	console.log('hello')
})
```

##### 4.Vuex
```js
import { createStore } from 'vuex'
const store = createStore({
	state: () => {
		return {
			message: 'xbc'
		}
	},
	getters: {},
	mutation: {
		changeMessage(state, newMessage) {
			state.message = newMessage
		}
	},
	actions: {
		change({commit}, payload) {
			commit('changeMessage', payload)
		}
	},
	modules: {}
})
export default store


<button @click = 'change'>

import {useStore} from 'vuex'
const store = useStore()
const change = () => {
	store.dispatch('change', 'xbcny')
}
```

## 2.组件实例
	通过组件实例获取组件里面的方法或者属性

```js
const child = ref(null)

<ChildCpn ref="child" />

// child.method
```

## 3.watch与watchEffect的区别
	watch函数监听特定的数据，并在回调函数中执行副作用，默认情况下第一次是不会执行的，响应式状态发生变化时才会触发回调函数
	watchEffect，我们希望在创建侦听器时，立即执行一遍回调
	手动停止监听，调用 watch 或 watchEffect 返回的函数
```js
watch(source, callback, [options])
source: ref (包括计算属性)、响应式对象、getter 函数、或多个数据源组成的数组
callback: 回调函数
options: 
	deep(深度监听，遍历被监听对象中所有被嵌套的属性) 
	immediate(watch监听是惰性的，设置了之后第一次会立即执行) 
	flush(当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。
	默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。
	如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: 'post' )，或者使用，watchPostEffect(() => {
  	/* 在 Vue 更新后执行 */
	})

watchEffect(() => {})
```